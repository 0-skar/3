import asyncio
import json
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

chat_history: List[Dict[str, str]] = []

class ConnectionManager:
    def __init__(self):
        # Przechowujemy mapowanie w obie strony dla większej wydajności
        self.ws_to_user: Dict[WebSocket, str] = {}
        self.user_to_ws: Dict[str, WebSocket] = {}

    def get_active_users(self) -> List[str]:
        return list(self.user_to_ws.keys())

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        # Początkowo połączenie jest anonimowe
        self.ws_to_user[websocket] = None

    def disconnect(self, websocket: WebSocket):
        username = self.ws_to_user.pop(websocket, None)
        if username and username in self.user_to_ws:
            del self.user_to_ws[username]

    async def assign_username(self, websocket: WebSocket, username: str):
        self.ws_to_user[websocket] = username
        self.user_to_ws[username] = websocket

    async def broadcast(self, message: str):
        for websocket in self.ws_to_user:
            await websocket.send_text(message)
    
    async def send_to_user(self, username: str, message: str):
        websocket = self.user_to_ws.get(username)
        if websocket:
            await websocket.send_text(message)

manager = ConnectionManager()

def create_packet(type: str, payload: dict) -> str:
    return json.dumps({"type": type, "payload": payload})

@app.get("/history")
async def get_history():
    return JSONResponse(content=[msg for msg in chat_history if msg.get("username") != "System"])

@app.websocket("/ws/")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    username = None
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            msg_type = message.get("type")

            if msg_type == "join":
                username = message["payload"]["username"]
                await manager.assign_username(websocket, username)
                
                system_msg_payload = {"username": "System", "message": f"{username} dołączył(a) do czatu."}
                await manager.broadcast(create_packet("chat_message", system_msg_payload))
                
                users_payload = {"users": manager.get_active_users()}
                await manager.broadcast(create_packet("user_update", users_payload))

            elif msg_type == "chat_message" and username:
                chat_payload = {"username": username, "message": message["payload"]["message"]}
                chat_history.append(chat_payload)
                if len(chat_history) > 100: chat_history.pop(0)
                
                await manager.broadcast(create_packet("chat_message", chat_payload))

            # NOWA LOGIKA: Obsługa wiadomości prywatnych
            elif msg_type == "private_message" and username:
                recipient = message["payload"]["recipient"]
                private_msg_payload = {
                    "sender": username,
                    "recipient": recipient,
                    "message": message["payload"]["message"]
                }
                
                # Wyślij wiadomość do odbiorcy i do nadawcy (aby obaj ją widzieli)
                await manager.send_to_user(recipient, create_packet("private_message", private_msg_payload))
                await manager.send_to_user(username, create_packet("private_message", private_msg_payload))

    except WebSocketDisconnect:
        manager.disconnect(websocket)
        if username:
            system_msg_payload = {"username": "System", "message": f"{username} opuścił(a) czat."}
            await manager.broadcast(create_packet("chat_message", system_msg_payload))
            
            users_payload = {"users": manager.get_active_users()}
            await manager.broadcast(create_packet("user_update", users_payload))
    except Exception as e:
        print(f"Error: {e}")
        manager.disconnect(websocket)
