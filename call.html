<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kontakty</title>
    <link rel="manifest" href="manifest.json?v=18">
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <style>
        :root {
            --bg-color: #23272a; --header-color: #1e2124; --text-color: #fff;
            --accent-color: #7289da; --green: #43b581; --red: #dc3545; --grey: #99aab5;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); display: flex; flex-direction: column; }
        header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background-color: var(--header-color); flex-shrink: 0; }
        header a, header button { color: var(--grey); text-decoration: none; background: none; border: none; font-size: 1.8rem; cursor: pointer; padding: 5px; }
        #install-button { display: none; }
        #call-area { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px; }
        #caller-info { height: 60px; }
        #caller-name { font-size: 2.2rem; font-weight: bold; }
        #call-status { font-size: 1rem; color: var(--grey); margin-top: 5px; }
        #main-call-button { width: 100px; height: 100px; border-radius: 50%; border: none; font-size: 3rem; margin-top: 40px; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .idle { background-color: var(--accent-color); }
        .calling-out, .in-call { background-color: var(--red); }
        .calling-in { background-color: var(--green); }
        footer { padding: 15px; background-color: var(--header-color); flex-shrink: 0; text-align: center; }
        #toggle-contacts-btn { font-size: 2rem; color: var(--accent-color); background: none; border: none; cursor: pointer; }
        #contacts-panel { position: fixed; bottom: 0; left: 0; right: 0; background-color: #2c2f33; border-top: 1px solid #444; max-height: 70%; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s ease-in-out; z-index: 100; }
        #contacts-panel.visible { transform: translateY(0); }
        #contacts-header { padding: 15px; text-align: center; font-weight: bold; border-bottom: 1px solid #444; cursor: pointer; }
        #contacts-header:hover { color: var(--accent-color); }
        #contacts-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; }
        .contact-item { display: flex; align-items: center; padding: 15px; }
        .contact-name { flex-grow: 1; }
        .contact-call-btn { font-size: 1.5rem; color: var(--green); background: none; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <header>
        <a id="forum-link" href="https://0-skar.github.io/3/" title="Przejd≈∫ do forum">‚åÇ</a>
        <button id="install-button" title="Zapisz na pulpicie">üìå</button>
        <button id="close-button" title="Zako≈Ñcz / Id≈∫ do Forum">‚ùå</button>
    </header>
    <main id="call-area">
        <div id="caller-info">
            <div id="caller-name">Gotowy</div>
            <div id="call-status">Wybierz kontakt, aby zadzwoniƒá</div>
        </div>
        <button id="main-call-button" class="idle">üìû</button>
    </main>
    <footer>
        <button id="toggle-contacts-btn" title="Ulubione Kontakty">‚≠ê</button>
    </footer>
    <div id="contacts-panel">
        <div id="contacts-header">Ulubione Kontakty</div>
        <ul id="contacts-list"></ul>
    </div>
    <script>
        const hfSpaceUrl = "eosforus-chat.hf.space"; const wsUrl = `wss://${hfSpaceUrl}/ws/`;
        let socket, myUsername, peerConnection, currentCallPartner; let callState = 'IDLE';
        let ringtone = null;

        const ui = { installButton: document.getElementById('install-button'), forumLink: document.getElementById('forum-link'), closeButton: document.getElementById('close-button'), callerName: document.getElementById('caller-name'), callStatus: document.getElementById('call-status'), mainCallButton: document.getElementById('main-call-button'), toggleContactsBtn: document.getElementById('toggle-contacts-btn'), contactsPanel: document.getElementById('contacts-panel'), contactsHeader: document.getElementById('contacts-header'), contactsList: document.getElementById('contacts-list'), };
        
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        function initializeApp() {
            setupEventListeners();
            const urlParams = new URLSearchParams(window.location.search);
            const caller = urlParams.get('caller');
            connectForContacts(() => { 
                if (caller) {
                    if (ringtone) ringtone.pause();
                    ringtone = new Audio('ringtone.mp3');
                    ringtone.loop = true;
                    ringtone.play().catch(e => {});
                    setState('INCOMING_CALL', { name: caller });
                }
            });
        }
        
        function setupEventListeners() {
            let deferredPrompt;
            window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; ui.installButton.style.display = 'block'; });
            ui.installButton.addEventListener('click', () => { if (deferredPrompt) deferredPrompt.prompt(); });

            ui.closeButton.addEventListener('click', () => {
                if (callState !== 'IDLE') {
                    if (peerConnection) peerConnection.close();
                    if (ringtone) ringtone.pause();
                    if (socket?.readyState === WebSocket.OPEN && currentCallPartner) {
                        socket.send(JSON.stringify({ type: 'webrtc_signal', payload: { recipient: currentCallPartner, signal: { type: 'hangup' } } }));
                    }
                    setState('IDLE', { status: "Gotowy do nowego po≈ÇƒÖczenia" });
                } else {
                    window.location.href = ui.forumLink.href; // Niezawodne przeniesienie na forum
                }
            });

            ui.toggleContactsBtn.addEventListener('click', () => ui.contactsPanel.classList.add('visible'));
            ui.contactsHeader.addEventListener('click', () => ui.contactsPanel.classList.remove('visible'));
            ui.mainCallButton.addEventListener('click', handleMainButtonClick);
        }
        
        function setState(newState, data = {}) { callState = newState; currentCallPartner = data.name || null; const forumBaseUrl = "https://0-skar.github.io/3/"; if (currentCallPartner) { ui.forumLink.href = `${forumBaseUrl}?action=autologin&chat_with=${currentCallPartner}`; } else { ui.forumLink.href = `${forumBaseUrl}?action=autologin`; } updateUI(data); }
        function updateUI(data = {}) { const { name, status } = data; ui.mainCallButton.className = 'main-call-button'; switch (callState) { case 'INCOMING_CALL': ui.callerName.textContent = name; ui.callStatus.textContent = "Dzwoni do Ciebie..."; ui.mainCallButton.innerHTML = "üìû"; ui.mainCallButton.classList.add('calling-in'); break; case 'OUTGOING_CALL': ui.callerName.textContent = name; ui.callStatus.textContent = "Dzwonienie..."; ui.mainCallButton.innerHTML = "‚ùå"; ui.mainCallButton.classList.add('calling-out'); break; case 'IN_CALL': ui.callerName.textContent = name; ui.callStatus.textContent = "Trwa rozmowa"; ui.mainCallButton.innerHTML = "‚ùå"; ui.mainCallButton.classList.add('in-call'); break; default: ui.callerName.textContent = "Gotowy"; ui.callStatus.textContent = status || "Wybierz kontakt, aby zadzwoniƒá"; ui.mainCallButton.innerHTML = "üìû"; ui.mainCallButton.classList.add('idle'); break; } }
        
        function handleMainButtonClick() {
            if (ringtone) { ringtone.pause(); ringtone = null; }
            switch (callState) {
                case 'INCOMING_CALL':
                    connectForContacts(() => {
                        socket.send(JSON.stringify({ type: 'call_answered', payload: { caller: currentCallPartner } }));
                        initializeWebRTC(currentCallPartner);
                    });
                    break;
                case 'OUTGOING_CALL':
                case 'IN_CALL':
                    if (peerConnection) peerConnection.close();
                    if (socket?.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'webrtc_signal', payload: { recipient: currentCallPartner, signal: { type: 'hangup' } } }));
                    }
                    setState('IDLE', { status: "Rozmowa zako≈Ñczona" });
                    break;
            }
        }
        
        function connectForContacts(callback) {
            if (socket && socket.readyState === WebSocket.OPEN) { if (callback) callback(); return; }
            socket = new WebSocket(wsUrl);
            socket.onopen = () => { myUsername = localStorage.getItem('forumUsername'); if (myUsername) { socket.send(JSON.stringify({ type: 'join', payload: { username: myUsername, password: localStorage.getItem('forumPassword') || '' } })); } else { updateUI({ status: "Zaloguj siƒô na forum" }); } };
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                switch (data.type) {
                    case 'join_success': if (callback) callback(); break;
                    case 'user_update': renderContacts(data.payload.users); break;
                    case 'webrtc_signal': handleWebRTCSignal(data.payload.sender, data.payload.signal); break;
                    case 'incoming_call_online':
                        if (callState !== 'IDLE') return;
                        if (ringtone) ringtone.pause();
                        ringtone = new Audio('ringtone.mp3');
                        ringtone.loop = true;
                        ringtone.play().catch(e => {});
                        setState('INCOMING_CALL', { name: data.payload.caller });
                        break;
                    case 'call_answered': setState('IN_CALL', { name: data.payload.callee }); break;
                    case 'call_declined': case 'recipient_busy': setState('IDLE', { status: `${data.payload.recipient || data.payload.callee} jest niedostƒôpny.` }); break;
                }
            };
            socket.onclose = () => updateUI({ status: "Roz≈ÇƒÖczono" });
        }
        
        function renderContacts(allUsers) { const me = allUsers.find(u => u.username === myUsername); ui.contactsList.innerHTML = ''; if (!me || !me.relationships) return; const favorites = Object.keys(me.relationships).filter(u => me.relationships[u] === 'favorite'); if (favorites.length === 0) { ui.contactsList.innerHTML = '<li class="contact-item" style="justify-content: center;">Brak ulubionych</li>'; return; } favorites.forEach(username => { const li = document.createElement('li'); li.className = 'contact-item'; li.innerHTML = `<span class="contact-name">${username}</span><button class="contact-call-btn" title="Zadzwo≈Ñ do ${username}">üìû</button>`; li.querySelector('.contact-call-btn').onclick = () => { connectForContacts(() => { ui.contactsPanel.classList.remove('visible'); setState('OUTGOING_CALL', { name: username }); socket.send(JSON.stringify({ type: 'initiate_call', payload: { recipient: username } })); initializeWebRTC(username); }); }; ui.contactsList.appendChild(li); }); }
        async function initializeWebRTC(targetUser) { try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); peerConnection = createPeerConnection(targetUser); stream.getTracks().forEach(track => peerConnection.addTrack(track, stream)); if (callState === 'OUTGOING_CALL') { const offer = await peerConnection.createOffer(); await peerConnection.setLocalDescription(offer); sendSignal(targetUser, { type: 'offer', sdp: offer.sdp }); } } catch (err) { setState('IDLE', { status: "B≈ÇƒÖd mikrofonu" }); } }
        function createPeerConnection(targetUser) { const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }); pc.onicecandidate = e => e.candidate && sendSignal(targetUser, { type: 'ice-candidate', candidate: e.candidate }); pc.ontrack = e => { const audio = document.createElement('audio'); audio.srcObject = e.streams[0]; audio.autoplay = true; document.body.appendChild(audio); setState('IN_CALL', { name: targetUser }); }; pc.onconnectionstatechange = () => { if (['disconnected', 'closed', 'failed'].includes(pc.connectionState)) { if (callState !== 'IDLE') setState('IDLE', { status: "Po≈ÇƒÖczenie zako≈Ñczone." }); peerConnection = null; } }; return pc; }
        function sendSignal(recipient, signal) { if (socket?.readyState === WebSocket.OPEN) { socket.send(JSON.stringify({ type: 'webrtc_signal', payload: { recipient, signal } })); } }
        async function handleWebRTCSignal(sender, signal) { if (!peerConnection) initializeWebRTC(sender); try { if (signal.type === 'offer') { await peerConnection.setRemoteDescription(new RTCSessionDescription(signal)); const answer = await peerConnection.createAnswer(); await peerConnection.setLocalDescription(answer); sendSignal(sender, { type: 'answer', sdp: answer.sdp }); } else if (signal.type === 'answer') { await peerConnection.setRemoteDescription(new RTCSessionDescription(signal)); } else if (signal.type === 'ice-candidate') { await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate)); } else if (signal.type === 'hangup') { if (peerConnection) peerConnection.close(); } } catch (err) { console.error("B≈ÇƒÖd WebRTC Signal:", err); } }
    </script>
</body>
</html>
